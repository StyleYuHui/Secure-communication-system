/* code: UTF-8  */
// This interface file is generated by cbindgen, and the comments are written by PaperPlane on 2025/6/7

#ifndef CRYPTO_RUST_EXPORT
#define CRYPTO_RUST_EXPORT

#include <cstdarg>
#include <cstdint>
#include <cstdlib>
#include <ostream>
#include <new>

/**
 * Crypto DLL Interface
 * Exposed by Rust library for AES, RSA, ElGamal cryptographic operations.
 *
 * All string parameters like keys, IVs, nonces should be passed as hexadecimal strings (ASCII characters, not binary).
 * Each hex character represents 4 bits, 2 hex characters = 1 byte.
 *
 * Errors:
 *   CRYPTO_SUCCESS                = 0    Operation succeeded.
 *   CRYPTO_ERROR_INVALID_PARAMETER = -1   Invalid input parameter.
 *   CRYPTO_ERROR_BUFFER_TOO_SMALL  = -2   Output buffer too small.
 *   CRYPTO_ERROR_INTERNAL          = -3   Internal library error.
 */

constexpr static const int32_t CRYPTO_SUCCESS = 0;

constexpr static const int32_t CRYPTO_ERROR_INVALID_PARAMETER = -1;

constexpr static const int32_t CRYPTO_ERROR_BUFFER_TOO_SMALL = -2;

constexpr static const int32_t CRYPTO_ERROR_INTERNAL = -3;


/**
 * 通用约定：
 * - key_hex、iv_hex、nonce_hex 等为十六进制字符串（不带 "0x"，如 "00112233445566778899AABBCCDDEEFF"）
 * - key 必须为 16 字节 (128-bit)，即 hex 长度 32 字符（不足时高位补 0）
 * - IV/nonce 通常为 16 字节 (hex 长度 32)
 * - 加密结果/解密结果通过 out_buffer 传出，调用前需设置 out_len 为 buffer 实际大小
 * - 若 out_buffer 不足，返回 CRYPTO_ERROR_BUFFER_TOO_SMALL，且 out_len 设置为所需大小
 */

extern "C" {


// =================== AES ECB ===================

/**
 * AES ECB 加密（带填充）
 * @param key_hex        十六进制密钥字符串
 * @param key_hex_len    密钥字符串长度
 * @param data           明文数据
 * @param data_len       明文数据长度
 * @param out_buffer     输出密文缓冲区
 * @param out_len        输入：缓冲区长度；输出：实际写入长度
 * @return 错误码
 * **/

int32_t crypto_aes_ecb_encrypt(const uint8_t *key_hex,
                               uintptr_t key_hex_len,
                               const uint8_t *data,
                               uintptr_t data_len,
                               uint8_t *out_buffer,
                               uintptr_t *out_len);

int32_t crypto_aes_ecb_decrypt(const uint8_t *key_hex,
                               uintptr_t key_hex_len,
                               const uint8_t *data,
                               uintptr_t data_len,
                               uint8_t *out_buffer,
                               uintptr_t *out_len);
// AES ECB 无填充版

int32_t crypto_aes_ecb_no_padding_encrypt(const uint8_t *key_hex,
                                          uintptr_t key_hex_len,
                                          const uint8_t *data,
                                          uintptr_t data_len,
                                          uint8_t *out_buffer,
                                          uintptr_t *out_len);

int32_t crypto_aes_ecb_no_padding_decrypt(const uint8_t *key_hex,
                                          uintptr_t key_hex_len,
                                          const uint8_t *data,
                                          uintptr_t data_len,
                                          uint8_t *out_buffer,
                                          uintptr_t *out_len);
// =================== AES CBC ===================

/**
 * AES CBC 加密（带填充）
 * @param iv_hex         IV 初始化向量（hex字符串）
 */

int32_t crypto_aes_cbc_encrypt(const uint8_t *key_hex,
                               uintptr_t key_hex_len,
                               const uint8_t *iv_hex,
                               uintptr_t iv_hex_len,
                               const uint8_t *data,
                               uintptr_t data_len,
                               uint8_t *out_buffer,
                               uintptr_t *out_len);

int32_t crypto_aes_cbc_decrypt(const uint8_t *key_hex,
                               uintptr_t key_hex_len,
                               const uint8_t *iv_hex,
                               uintptr_t iv_hex_len,
                               const uint8_t *data,
                               uintptr_t data_len,
                               uint8_t *out_buffer,
                               uintptr_t *out_len);

int32_t crypto_aes_cbc_no_padding_encrypt(const uint8_t *key_hex,
                                          uintptr_t key_hex_len,
                                          const uint8_t *iv_hex,
                                          uintptr_t iv_hex_len,
                                          const uint8_t *data,
                                          uintptr_t data_len,
                                          uint8_t *out_buffer,
                                          uintptr_t *out_len);

int32_t crypto_aes_cbc_no_padding_decrypt(const uint8_t *key_hex,
                                          uintptr_t key_hex_len,
                                          const uint8_t *iv_hex,
                                          uintptr_t iv_hex_len,
                                          const uint8_t *data,
                                          uintptr_t data_len,
                                          uint8_t *out_buffer,
                                          uintptr_t *out_len);

// =================== AES CTR ===================

/**
 * AES CTR 加密/解密（CTR模式加密解密是对称的）
 * @param nonce_hex 作为nonce
 */

int32_t crypto_aes_ctr_encrypt(const uint8_t *key_hex,
                               uintptr_t key_hex_len,
                               const uint8_t *nonce_hex,
                               uintptr_t nonce_hex_len,
                               const uint8_t *data,
                               uintptr_t data_len,
                               uint8_t *out_buffer,
                               uintptr_t *out_len);

int32_t crypto_aes_ctr_decrypt(const uint8_t *key_hex,
                               uintptr_t key_hex_len,
                               const uint8_t *nonce_hex,
                               uintptr_t nonce_hex_len,
                               const uint8_t *data,
                               uintptr_t data_len,
                               uint8_t *out_buffer,
                               uintptr_t *out_len);

// =================== AES OFB ===================

int32_t crypto_aes_ofb_encrypt(const uint8_t *key_hex,
                               uintptr_t key_hex_len,
                               const uint8_t *iv_hex,
                               uintptr_t iv_hex_len,
                               const uint8_t *data,
                               uintptr_t data_len,
                               uint8_t *out_buffer,
                               uintptr_t *out_len);

int32_t crypto_aes_ofb_decrypt(const uint8_t *key_hex,
                               uintptr_t key_hex_len,
                               const uint8_t *iv_hex,
                               uintptr_t iv_hex_len,
                               const uint8_t *data,
                               uintptr_t data_len,
                               uint8_t *out_buffer,
                               uintptr_t *out_len);

// =================== AES CFB ===================

int32_t crypto_aes_cfb_encrypt(const uint8_t *key_hex,
                               uintptr_t key_hex_len,
                               const uint8_t *iv_hex,
                               uintptr_t iv_hex_len,
                               const uint8_t *data,
                               uintptr_t data_len,
                               uint8_t *out_buffer,
                               uintptr_t *out_len);

int32_t crypto_aes_cfb_decrypt(const uint8_t *key_hex,
                               uintptr_t key_hex_len,
                               const uint8_t *iv_hex,
                               uintptr_t iv_hex_len,
                               const uint8_t *data,
                               uintptr_t data_len,
                               uint8_t *out_buffer,
                               uintptr_t *out_len);


// =================== RSA ===================

/**
 * 生成RSA密钥对
 * @param bit_length    密钥位数（例如2048）
 * @param n_buffer      modulus n（十进制字符串）
 * @param n_len
 * @param e_buffer      公钥 e（十进制字符串）
 * @param e_len
 * @param d_buffer      私钥 d（十进制字符串）
 * @param d_len
 * @return 错误码
 */

int32_t crypto_rsa_generate_keys(uintptr_t bit_length,
                                 uint8_t *n_buffer,
                                 uintptr_t *n_len,
                                 uint8_t *e_buffer,
                                 uintptr_t *e_len,
                                 uint8_t *d_buffer,
                                 uintptr_t *d_len);

/**
 * 使用RSA公钥加密
 * @param n,e     公钥参数（十进制字符串）
 * @param message 明文数据
 * @param out_buffer 加密结果
 */

int32_t crypto_rsa_encrypt(const uint8_t *n,
                           uintptr_t n_len,
                           const uint8_t *e,
                           uintptr_t e_len,
                           const uint8_t *message,
                           uintptr_t message_len,
                           uint8_t *out_buffer,
                           uintptr_t *out_len);

/**
 * 使用RSA私钥解密
 * @param n,d     私钥参数（十进制字符串）
 * @param ciphertext 密文数据
 */

int32_t crypto_rsa_decrypt(const uint8_t *n,
                           uintptr_t n_len,
                           const uint8_t *d,
                           uintptr_t d_len,
                           const uint8_t *ciphertext,
                           uintptr_t ciphertext_len,
                           uint8_t *out_buffer,
                           uintptr_t *out_len);


// =================== ElGamal ===================

/**
 * 生成ElGamal密钥对
 * @param bit_length 密钥位数
 * @param p,g,y,x    分别是大素数p、生成元g、公钥y、私钥x（十进制字符串）
 */

int32_t crypto_elgamal_generate_keys(uintptr_t bit_length,
                                     uint8_t *p_buffer,
                                     uintptr_t *p_len,
                                     uint8_t *g_buffer,
                                     uintptr_t *g_len,
                                     uint8_t *y_buffer,
                                     uintptr_t *y_len,
                                     uint8_t *x_buffer,
                                     uintptr_t *x_len);

/**
 * ElGamal加密
 * @param message 传入字符串，内部会hash成大数
 * @param c1,c2   输出 ElGamal 密文对（十进制字符串）
 */

int32_t crypto_elgamal_encrypt(const uint8_t *p,
                               uintptr_t p_len,
                               const uint8_t *g,
                               uintptr_t g_len,
                               const uint8_t *y,
                               uintptr_t y_len,
                               const uint8_t *message,
                               uintptr_t message_len,
                               uint8_t *c1_buffer,
                               uintptr_t *c1_len,
                               uint8_t *c2_buffer,
                               uintptr_t *c2_len);


/**
 * ElGamal解密
 * @param c1,c2 ElGamal密文对（十进制字符串）
 * @param out_buffer 解密结果（原字符串）
 */

int32_t crypto_elgamal_decrypt(const uint8_t *p,
                               uintptr_t p_len,
                               const uint8_t *g,
                               uintptr_t g_len,
                               const uint8_t *x,
                               uintptr_t x_len,
                               const uint8_t *c1,
                               uintptr_t c1_len,
                               const uint8_t *c2,
                               uintptr_t c2_len,
                               uint8_t *out_buffer,
                               uintptr_t *out_len);

/**
 * ElGamal 签名
 * @param p           素数 p （十进制字符串，UTF-8编码的字节数组）
 * @param p_len       p 的字节长度
 * @param g           生成元 g （十进制字符串）
 * @param g_len       g 的字节长度
 * @param x           私钥 x （十进制字符串）
 * @param x_len       x 的字节长度
 * @param message     待签名的消息（任意字节序列）
 * @param message_len 消息长度
 * @param r_buffer    签名 r （十进制字符串），调用方分配内存
 * @param r_len       输入：r_buffer 缓冲区长度；输出：实际写入的长度
 * @param s_buffer    签名 s （十进制字符串），调用方分配内存
 * @param s_len       输入：s_buffer 缓冲区长度；输出：实际写入的长度
 * @return 错误码（0=成功，其他=失败）
 */

int32_t crypto_elgamal_sign(const uint8_t *p,
                            uintptr_t p_len,
                            const uint8_t *g,
                            uintptr_t g_len,
                            const uint8_t *x,
                            uintptr_t x_len,
                            const uint8_t *message,
                            uintptr_t message_len,
                            uint8_t *r_buffer,
                            uintptr_t *r_len,
                            uint8_t *s_buffer,
                            uintptr_t *s_len);

/**
 * ElGamal 验签
 * @param p           素数 p （十进制字符串）
 * @param p_len       p 的字节长度
 * @param g           生成元 g （十进制字符串）
 * @param g_len       g 的字节长度
 * @param y           公钥 y （十进制字符串）
 * @param y_len       y 的字节长度
 * @param message     待验证的消息（任意字节序列）
 * @param message_len 消息长度
 * @param r           签名 r （十进制字符串）
 * @param r_len       r 的字节长度
 * @param s           签名 s （十进制字符串）
 * @param s_len       s 的字节长度
 * @return 错误码
 *         - 0 = 签名有效
 *         - 1 = 签名无效
 *         - 其他 = 错误（如参数错误、内部错误）
 */

int32_t crypto_elgamal_verify(const uint8_t *p,
                              uintptr_t p_len,
                              const uint8_t *g,
                              uintptr_t g_len,
                              const uint8_t *y,
                              uintptr_t y_len,
                              const uint8_t *message,
                              uintptr_t message_len,
                              const uint8_t *r,
                              uintptr_t r_len,
                              const uint8_t *s,
                              uintptr_t s_len);

}  // extern "C"
#endif     // CRYPTO_RUST_EXPORT